/**
 * Memory Bank Management Controller
 * 
 * Provides REST API access to the memory bank (rules system) for managing
 * persistent knowledge, patterns, and preferences across tasks.
 */

import {
	Controller,
	Route,
	Get,
	Post,
	Patch,
	Delete,
	Path,
	Query,
	Body,
	Security,
	SuccessResponse,
	Response,
} from "tsoa"
import type { ClineProvider } from "../../../core/webview/ClineProvider"
import type { ApiErrorResponse } from "../api-types"
import { BadRequestError, NotFoundError, ConflictError } from "../errors"
import { getEnabledRules, toggleRule, createRuleFile, deleteRuleFile } from "../../../core/webview/hoodyrules"
import { readTextFilesFromDirectory } from "../../../core/prompts/sections/custom-instructions"
import { GlobalFileNames } from "../../../shared/globalFileNames"
import { allowedExtensions } from "../../../shared/hoodycode/rules"
import * as path from "path"
import * as fs from "fs/promises"
import * as os from "os"
import { fileExistsAtPath } from "../../../utils/fs"
import crypto from "crypto"

// Dependency injection
let providerInstance: ClineProvider | null = null

export function setMemoryBankControllerProvider(provider: ClineProvider) {
	providerInstance = provider
}

function getProvider(): ClineProvider {
	if (!providerInstance) {
		throw new Error("MemoryBankController: Provider not initialized")
	}
	return providerInstance
}

// ============================================================================
// Type Definitions
// ============================================================================

/**
 * Memory entry metadata
 * @example {
 *   "id": "mem_a1b2c3",
 *   "path": "api-patterns.md",
 *   "title": "REST API Design Patterns",
 *   "content": "# REST API Design Patterns\n\nAlways use plural nouns for resource endpoints...",
 *   "scope": "global",
 *   "category": "best-practices",
 *   "tags": ["api", "rest", "design"],
 *   "enabled": true,
 *   "createdAt": "2024-01-15T10:30:00.000Z",
 *   "updatedAt": "2024-01-20T14:45:00.000Z",
 *   "size": 2048
 * }
 */
export interface MemoryEntry {
	/** Unique memory ID (e.g., mem_abc123) */
	id: string
	/** File path relative to rules directory */
	path: string
	/** Human-readable title */
	title: string
	/** Markdown content */
	content: string
	/** Storage scope */
	scope: "global" | "local"
	/** Optional category */
	category?: string
	/** Optional tags */
	tags?: string[]
	/** Enabled status */
	enabled: boolean
	/** Creation timestamp */
	createdAt: string
	/** Last update timestamp */
	updatedAt: string
	/** File size in bytes */
	size?: number
	/** Metadata */
	metadata?: {
		source?: string
		taskId?: string
		autoGenerated?: boolean
	}
}

/**
 * Memory list response
 */
export interface MemoryListResponse {
	/** Memory entries */
	entries: MemoryEntry[]
	/** Total count */
	count: number
	/** Scope filter applied */
	scope?: "global" | "local" | "all"
}

/**
 * Create memory request
 * @example {
 *   "filename": "error-handling-pattern.md",
 *   "content": "# Error Handling Pattern\n\nAlways wrap async operations in try-catch blocks...",
 *   "scope": "local",
 *   "category": "patterns",
 *   "tags": ["error-handling", "async"]
 * }
 */
export interface CreateMemoryRequest {
	/** File name (e.g., "api-patterns.md") */
	filename: string
	/** Markdown content */
	content: string
	/** Storage scope */
	scope: "global" | "local"
	/** Optional category */
	category?: string
	/** Optional tags */
	tags?: string[]
	/** Optional metadata */
	metadata?: {
		source?: string
		taskId?: string
		autoGenerated?: boolean
	}
}

/**
 * Create memory response
 */
export interface CreateMemoryResponse {
	success: true
	message: string
	/** Created memory entry */
	entry: MemoryEntry
}

/**
 * Update memory request
 * @example {
 *   "content": "# Updated Error Handling Pattern\n\nAlways use specific error types...",
 *   "tags": ["error-handling", "async", "typescript"]
 * }
 */
export interface UpdateMemoryRequest {
	/** Updated content */
	content?: string
	/** Updated enabled status */
	enabled?: boolean
	/** Updated tags */
	tags?: string[]
	/** Updated category */
	category?: string
}

/**
 * Update memory response
 */
export interface UpdateMemoryResponse {
	success: true
	message: string
	/** Updated memory entry */
	entry: MemoryEntry
}

/**
 * Delete memory response
 */
export interface DeleteMemoryResponse {
	success: true
	message: string
}

/**
 * Toggle memory response
 */
export interface ToggleMemoryResponse {
	success: true
	message: string
	enabled: boolean
}

/**
 * Memory search result
 */
export interface MemorySearchResult {
	/** Memory entry */
	entry: MemoryEntry
	/** Relevance score (0-1) */
	score: number
	/** Matched snippets */
	matches?: string[]
}

/**
 * Memory search response
 */
export interface MemorySearchResponse {
	/** Search results */
	results: MemorySearchResult[]
	/** Total results */
	count: number
	/** Search query */
	query: string
}

/**
 * Memory statistics response
 */
export interface MemoryStatsResponse {
	/** Total memory entries */
	total: number
	/** Enabled entries */
	enabled: number
	/** Disabled entries */
	disabled: number
	/** Global entries */
	global: number
	/** Local entries */
	local: number
	/** Total size in bytes */
	totalSize: number
	/** Categories breakdown */
	categories: Record<string, number>
}

/**
 * AI suggestion for memory creation
 */
export interface MemorySuggestion {
	/** Suggestion type */
	type: "repetition" | "success" | "error_fix" | "best_practice"
	/** Suggested title */
	title: string
	/** Reason for suggestion */
	reason: string
	/** Proposed content */
	proposedContent: string
	/** Confidence score (0-1) */
	confidence: number
}

/**
 * Memory suggestions response
 */
export interface MemorySuggestionsResponse {
	/** Suggestions */
	suggestions: MemorySuggestion[]
	/** Total suggestions */
	count: number
}

// ============================================================================
// Helper Functions
// ============================================================================

/**
 * Generate unique memory ID
 */
function generateMemoryId(): string {
	return `mem_${crypto.randomBytes(6).toString("hex")}`
}

/**
 * Get rules directory path
 */
function getRulesDir(scope: "global" | "local", cwd: string): string {
	if (scope === "global") {
		return path.join(os.homedir(), GlobalFileNames.hoodyRules)
	}
	return path.join(cwd, GlobalFileNames.hoodyRules)
}

/**
 * Extract title from markdown content
 */
function extractTitle(content: string, filename: string): string {
	// Try to extract from first # heading
	const match = content.match(/^#\s+(.+)$/m)
	if (match) {
		return match[1].trim()
	}
	// Fallback to filename without extension
	return path.basename(filename, path.extname(filename))
}

/**
 * Extract category from path
 */
function extractCategory(filePath: string): string | undefined {
	const parts = filePath.split(path.sep)
	// If file is in a subdirectory (e.g., memory-bank/), use that as category
	if (parts.length > 1) {
		return parts[parts.length - 2]
	}
	return undefined
}

/**
 * Convert file to MemoryEntry
 */
async function fileToMemoryEntry(
	filePath: string,
	scope: "global" | "local",
	enabled: boolean,
): Promise<MemoryEntry> {
	const content = await fs.readFile(filePath, "utf8")
	const stats = await fs.stat(filePath)
	const relativePath = path.relative(
		scope === "global" 
			? path.join(os.homedir(), GlobalFileNames.hoodyRules)
			: path.join(getProvider().cwd, GlobalFileNames.hoodyRules),
		filePath
	)

	return {
		id: generateMemoryId(),
		path: relativePath,
		title: extractTitle(content, path.basename(filePath)),
		content,
		scope,
		category: extractCategory(relativePath),
		enabled,
		createdAt: stats.birthtime.toISOString(),
		updatedAt: stats.mtime.toISOString(),
		size: stats.size,
	}
}

/**
 * Recursively scan directory for rule files
 */
async function scanRulesDirectory(
	dirPath: string,
	toggleState: Record<string, boolean>,
): Promise<Record<string, boolean>> {
	const rules: Record<string, boolean> = {}
	
	try {
		const exists = await fileExistsAtPath(dirPath)
		if (!exists) {
			return rules
		}

		const entries = await fs.readdir(dirPath, { withFileTypes: true })
		
		for (const entry of entries) {
			const fullPath = path.join(dirPath, entry.name)
			
			if (entry.isDirectory()) {
				// Recursively scan subdirectories
				const subRules = await scanRulesDirectory(fullPath, toggleState)
				Object.assign(rules, subRules)
			} else if (entry.isFile()) {
				// Check if file has allowed extension
				const hasValidExt = allowedExtensions.some(ext =>
					entry.name.toLowerCase().endsWith(ext)
				)
				if (hasValidExt) {
					rules[fullPath] = toggleState[fullPath] ?? true
				}
			}
		}
	} catch (error) {
		console.error(`Error scanning directory ${dirPath}:`, error)
	}
	
	return rules
}

/**
 * List all memory entries
 */
async function listMemoryEntries(
	scope: "global" | "local" | "all",
	cwd: string,
	contextProxy: any,
	context: any,
): Promise<MemoryEntry[]> {
	const entries: MemoryEntry[] = []

	// Get toggle states
	const globalToggles = ((await contextProxy.getGlobalState("globalRulesToggles")) as Record<string, boolean>) || {}
	const localToggles = ((await contextProxy.getWorkspaceState(context, "localRulesToggles")) as Record<string, boolean>) || {}

	// Process global rules
	if (scope === "global" || scope === "all") {
		const globalDir = path.join(os.homedir(), GlobalFileNames.hoodyRules)
		const globalRules = await scanRulesDirectory(globalDir, globalToggles)
		
		for (const [filePath, enabled] of Object.entries(globalRules)) {
			try {
				const entry = await fileToMemoryEntry(filePath, "global", enabled)
				entries.push(entry)
			} catch (error) {
				console.error(`Failed to read global rule ${filePath}:`, error)
			}
		}
	}

	// Process local rules
	if (scope === "local" || scope === "all") {
		const localDir = path.join(cwd, GlobalFileNames.hoodyRules)
		const localRules = await scanRulesDirectory(localDir, localToggles)
		
		for (const [filePath, enabled] of Object.entries(localRules)) {
			try {
				const entry = await fileToMemoryEntry(filePath, "local", enabled)
				entries.push(entry)
			} catch (error) {
				console.error(`Failed to read local rule ${filePath}:`, error)
			}
		}
	}

	return entries
}

/**
 * Find memory entry by ID or path
 */
async function findMemoryEntry(
	idOrPath: string,
	cwd: string,
	contextProxy: any,
	context: any,
): Promise<MemoryEntry | null> {
	const entries = await listMemoryEntries("all", cwd, contextProxy, context)
	
	// Try to find by ID first
	let entry = entries.find(e => e.id === idOrPath)
	if (entry) return entry

	// Try to find by path
	entry = entries.find(e => e.path === idOrPath || path.basename(e.path) === idOrPath)
	return entry || null
}

// ============================================================================
// Controller
// ============================================================================

@Route("memory-bank")
@Security("bearer")
export class MemoryBankController extends Controller {
	/**
	 * List all memory entries
	 * @summary List memory entries
	 * @param scope Filter by scope (global, local, all)
	 * @param enabled Filter by enabled status
	 * @param category Filter by category
	 */
	@Get()
	@SuccessResponse(200, "Memory entries listed")
	@Response<ApiErrorResponse>(500, "Internal server error")
	public async listMemories(
		@Query() scope?: "global" | "local" | "all",
		@Query() enabled?: boolean,
		@Query() category?: string,
	): Promise<MemoryListResponse> {
		const provider = getProvider()
		const filterScope = scope || "all"

		let entries = await listMemoryEntries(
			filterScope,
			provider.cwd,
			provider.contextProxy,
			provider.context,
		)

		// Apply filters
		if (enabled !== undefined) {
			entries = entries.filter(e => e.enabled === enabled)
		}
		if (category) {
			entries = entries.filter(e => e.category === category)
		}

		return {
			entries,
			count: entries.length,
			scope: filterScope,
		}
	}

	/**
	 * Get memory bank statistics
	 * @summary Get statistics
	 */
	@Get("stats")
	@SuccessResponse(200, "Statistics retrieved")
	public async getStats(): Promise<MemoryStatsResponse> {
		const provider = getProvider()
		const entries = await listMemoryEntries("all", provider.cwd, provider.contextProxy, provider.context)

		const stats: MemoryStatsResponse = {
			total: entries.length,
			enabled: entries.filter(e => e.enabled).length,
			disabled: entries.filter(e => !e.enabled).length,
			global: entries.filter(e => e.scope === "global").length,
			local: entries.filter(e => e.scope === "local").length,
			totalSize: entries.reduce((sum, e) => sum + (e.size || 0), 0),
			categories: {},
		}

		// Count by category
		entries.forEach(entry => {
			if (entry.category) {
				stats.categories[entry.category] = (stats.categories[entry.category] || 0) + 1
			}
		})

		return stats
	}

	/**
	 * Get specific memory entry
	 * @summary Get memory entry
	 * @param id Memory ID or path
	 */
	@Get("{id}")
	@SuccessResponse(200, "Memory entry retrieved")
	@Response<ApiErrorResponse>(404, "Memory entry not found")
	public async getMemory(@Path() id: string): Promise<MemoryEntry> {
		const provider = getProvider()
		const entry = await findMemoryEntry(id, provider.cwd, provider.contextProxy, provider.context)

		if (!entry) {
			throw new NotFoundError(`Memory entry '${id}' not found`)
		}

		return entry
	}

	/**
	 * Create new memory entry
	 * @summary Create memory
	 */
	@Post()
	@SuccessResponse(201, "Memory entry created")
	@Response<ApiErrorResponse>(400, "Bad request")
	@Response<ApiErrorResponse>(409, "Memory entry already exists")
	public async createMemory(@Body() request: CreateMemoryRequest): Promise<CreateMemoryResponse> {
		const provider = getProvider()

		if (!request.filename || !request.content) {
			throw new BadRequestError("filename and content are required")
		}

		// Validate filename extension
		const hasValidExt = allowedExtensions.some(ext => request.filename.toLowerCase().endsWith(ext))
		if (!hasValidExt) {
			throw new BadRequestError(`Filename must end with one of: ${allowedExtensions.join(", ")}`)
		}

		// Determine full path
		const rulesDir = getRulesDir(request.scope, provider.cwd)
		let filePath = path.join(rulesDir, request.filename)

		// If category specified, create in subdirectory
		if (request.category) {
			filePath = path.join(rulesDir, request.category, request.filename)
		}

		// Check if file already exists
		if (await fileExistsAtPath(filePath)) {
			throw new ConflictError(`Memory entry '${request.filename}' already exists`)
		}

		// Create directory if needed
		await fs.mkdir(path.dirname(filePath), { recursive: true })

		// Write file (using queue for concurrency protection)
		await fileWriteQueue.writeFile(filePath, request.content, "utf8")

		// Create entry object
		const entry = await fileToMemoryEntry(filePath, request.scope, true)

		// Add metadata if provided
		if (request.metadata) {
			entry.metadata = request.metadata
		}
		if (request.tags) {
			entry.tags = request.tags
		}

		this.setStatus(201)
		return {
			success: true,
			message: `Memory entry '${request.filename}' created successfully`,
			entry,
		}
	}

	/**
	 * Update memory entry
	 * @summary Update memory
	 * @param id Memory ID or path
	 */
	@Patch("{id}")
	@SuccessResponse(200, "Memory entry updated")
	@Response<ApiErrorResponse>(404, "Memory entry not found")
	public async updateMemory(
		@Path() id: string,
		@Body() request: UpdateMemoryRequest,
	): Promise<UpdateMemoryResponse> {
		const provider = getProvider()
		const entry = await findMemoryEntry(id, provider.cwd, provider.contextProxy, provider.context)

		if (!entry) {
			throw new NotFoundError(`Memory entry '${id}' not found`)
		}

		// Get full file path
		const rulesDir = getRulesDir(entry.scope, provider.cwd)
		const filePath = path.join(rulesDir, entry.path)

		// Update content if provided
		if (request.content !== undefined) {
			await fileWriteQueue.writeFile(filePath, request.content, "utf8")
			entry.content = request.content
			entry.updatedAt = new Date().toISOString()
		}

		// Update enabled status if provided
		if (request.enabled !== undefined && request.enabled !== entry.enabled) {
			await toggleRule(
				filePath,
				request.enabled,
				entry.scope === "global",
				provider.contextProxy,
				provider.context,
			)
			entry.enabled = request.enabled
		}

		// Update tags if provided
		if (request.tags !== undefined) {
			entry.tags = request.tags
		}

		// Update category if provided
		if (request.category !== undefined) {
			entry.category = request.category
		}

		return {
			success: true,
			message: `Memory entry '${id}' updated successfully`,
			entry,
		}
	}

	/**
	 * Delete memory entry
	 * @summary Delete memory
	 * @param id Memory ID or path
	 */
	@Delete("{id}")
	@SuccessResponse(204, "Memory entry deleted")
	@Response<ApiErrorResponse>(404, "Memory entry not found")
	public async deleteMemory(@Path() id: string): Promise<void> {
		const provider = getProvider()
		const entry = await findMemoryEntry(id, provider.cwd, provider.contextProxy, provider.context)

		if (!entry) {
			throw new NotFoundError(`Memory entry '${id}' not found`)
		}

		// Get full file path
		const rulesDir = getRulesDir(entry.scope, provider.cwd)
		const filePath = path.join(rulesDir, entry.path)

		// Delete file
		await fs.unlink(filePath)

		this.setStatus(204)
	}

	/**
	 * Toggle memory entry enabled status
	 * @summary Toggle memory
	 * @param id Memory ID or path
	 */
	@Post("{id}/toggle")
	@SuccessResponse(200, "Memory entry toggled")
	@Response<ApiErrorResponse>(404, "Memory entry not found")
	public async toggleMemory(@Path() id: string): Promise<ToggleMemoryResponse> {
		const provider = getProvider()
		const entry = await findMemoryEntry(id, provider.cwd, provider.contextProxy, provider.context)

		if (!entry) {
			throw new NotFoundError(`Memory entry '${id}' not found`)
		}

		// Get full file path
		const rulesDir = getRulesDir(entry.scope, provider.cwd)
		const filePath = path.join(rulesDir, entry.path)

		// Toggle enabled status
		const newEnabled = !entry.enabled
		await toggleRule(
			filePath,
			newEnabled,
			entry.scope === "global",
			provider.contextProxy,
			provider.context,
		)

		return {
			success: true,
			message: `Memory entry '${id}' ${newEnabled ? "enabled" : "disabled"}`,
			enabled: newEnabled,
		}
	}

	/**
	 * Search memory entries
	 * @summary Search memories
	 * @param query Search query
	 * @param scope Filter by scope
	 */
	@Post("search")
	@SuccessResponse(200, "Search completed")
	public async searchMemories(
		@Body() body: { query: string; scope?: "global" | "local" | "all" },
	): Promise<MemorySearchResponse> {
		const provider = getProvider()
		const { query, scope = "all" } = body

		if (!query) {
			throw new BadRequestError("query is required")
		}

		const entries = await listMemoryEntries(scope, provider.cwd, provider.contextProxy, provider.context)
		const queryLower = query.toLowerCase()

		// Simple text search (can be enhanced with fuzzy matching later)
		const results: MemorySearchResult[] = entries
			.map(entry => {
				const titleMatch = entry.title.toLowerCase().includes(queryLower)
				const contentMatch = entry.content.toLowerCase().includes(queryLower)
				const categoryMatch = entry.category?.toLowerCase().includes(queryLower)

				if (!titleMatch && !contentMatch && !categoryMatch) {
					return null
				}

				// Calculate simple relevance score
				let score = 0
				if (titleMatch) score += 0.5
				if (contentMatch) score += 0.3
				if (categoryMatch) score += 0.2

				return {
					entry,
					score,
					matches: [
						titleMatch ? `Title: ${entry.title}` : null,
						contentMatch ? "Content match found" : null,
					].filter(Boolean) as string[],
				}
			})
			.filter((r): r is MemorySearchResult => r !== null)
			.sort((a, b) => b.score - a.score)

		return {
			results,
			count: results.length,
			query,
		}
	}

	/**
	 * Get AI-powered memory suggestions
	 * @summary Get suggestions
	 */
	@Post("suggest")
	@SuccessResponse(200, "Suggestions generated")
	public async getSuggestions(
		@Body() body: { taskId?: string; context?: string },
	): Promise<MemorySuggestionsResponse> {
		// TODO: Implement AI-powered suggestion logic
		// This would analyze task history and patterns to suggest memory creation
		
		// For now, return empty suggestions
		return {
			suggestions: [],
			count: 0,
		}
	}
}